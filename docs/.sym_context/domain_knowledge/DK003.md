---
tags: [automation, github, ci/cd, analysis]
---

# DK-003: GitHub Automation Ecosystem Analysis

**Related Code:** `.github/workflows/`
**Last Updated:** 2026-01-04

## Definition
This analysis covers the lifecycle of the GitHub Actions automation suite for this NixOS repository, detailing how human inputs trigger automated responses and identifying potential failure modes.

---

## The Automation Lifecycle Flow

### 1. The Integration Pipeline (CI)

**Trigger:** `push` events to the main branch or `pull_request` events targeting the main branch.

**Technical Process:**
1.  **Environment Provisioning**: The workflow initializes an Ubuntu-latest runner.
2.  **Nix Installation**: `cachix/install-nix-action` bootstraps a multi-user Nix installation with flakes enabled. It automatically configures `nix.conf` to optimize for CI (reduced verbosity, increased jobs).
3.  **Binary Caching (Magic Nix Cache)**: The system attempts to fetch pre-built binaries for all inputs. If the exact closure hash exists in the cache (e.g., from a previous run or upstream), derivation building is skipped entirely.
4.  **Integrity Verification**: `nix flake check` runs to ensure:
    -   `flake.lock` is consistent with `flake.nix`.
    -   All exported packages, devShells, and overlays evaluate without errors.
    -   No unfree packages are referenced without valid licenses.
5.  **Host Building**: `nix build .#nixosConfigurations.<hostname>.config.system.build.toplevel` builds the entire system closure. This confirms that all modules merge correctly and no options conflict.

**Outcome:**
-   **Pass**: The configuration is syntactically valid and compiles. It does not guarantee runtime stability on hardware.
-   **Fail**: The commit introduces a syntax error, a missing dependency, or a conflicting module option.

### 2. The Dependency Maintenance Loop (Auto-Update)

**Trigger:** `schedule` event (Weekly Cron) or manual `workflow_dispatch`.

**Technical Process:**
1.  **Lockfile Evaluation**: `DeterminateSystems/update-flake-lock` reads the current `flake.lock`.
2.  **Upstream Fetch**: The action queries the `nixpkgs-unstable` (or other inputs) git refs to identify new commits.
3.  **Graph Resolution**: Nix calculates the new dependency graph. If conflicts arise (e.g., a plugin needs an older inputs), the update fails safely.
4.  **Pull Request Generation**: If updates are found, the action uses the `github-actions[bot]` identity to commit changes to a new branch and open a Pull Request.
    -   The PR description includes the exact commit range (e.g., `nixpkgs: 01-01 -> 01-08`) and links to the compare view.
    -   This triggers the **Integration Pipeline (CI)** described above to verify the new lockfile.

**Outcome:** A safe, isolated Pull Request waiting for maintainer review. It is never auto-merged to prevent shipping breaking changes to upstream packages.

### 3. The Contribution Triage System

**Trigger:** `pull_request` target events (opened, synchronized, reopened).

**Technical Process:**
1.  **Diff Analysis**: `actions/labeler` retrieves the list of changed files in the PR compared to the base branch.
2.  **Pattern Matching**: The file list is checked against glob patterns defined in `.github/labeler.yml`:
    -   `**/*.nix` -> `lang/nix`
    -   `.sym_context/**/*` -> `area/documentation`
    -   `.github/**/*` -> `area/automation`
    -   `hosts/**/*` -> `area/systems`
3.  **Label Application**: The GitHub API is called to apply the matching labels to the PR metadata.

**Outcome:** Maintainers can visualize the scope of changes (Documentation vs System Critical) from the PR list view without opening the diff.

---

## Weaknesses & Edge Cases

### 1. The "Cache Miss" Build Timeout (HIGH RISK)
**Scenario:** You change a core package (e.g., compile a custom Firefox).
**Symptom:** GitHub Action runs for 6 hours then times out or crashes.
**Weakness:** GitHub Free runners have 2 cores / 7GB RAM. Using Nix to build huge software on them is impossible.
**Mitigation:** `binary-cache` usage (Cachix) or excluding heavy builds from CI.

### 2. The "Update Breakage" (MEDIUM RISK)
**Scenario:** `update.yml` bumps `nixpkgs`. The build theoretically passes, but your Wifi stops working.
**Weakness:** CI only checks if code *compiles*, not if it *works* on hardware.
**Mitigation:** Only manual verification or complex VM tests (very long runtime) can solve this.

### 3. The "Flake Check" False Confidence (MEDIUM RISK)
**Scenario:** CI says "Green", but you forgot to `git add` a new file.
**Weakness:** `nix flake check` mostly checks valid syntax, it doesn't know about file system state outside git.
**Mitigation:** The `ci.yml` build step catches verify imports, but subtle logic bugs slip through.

### 4. Rate Limiting (LOW RISK)
**Scenario:** Pipeline fails with "403 Forbidden" or "API Rate Limit".
**Weakness:** GitHub limits API calls from Actions.
**Mitigation:** Automatically handled by `GITHUB_TOKEN`, usually fine for personal repos.

---

## Strategic Decisions (ADR Context)

| Decision | Why? |
|----------|------|
| **Use `install-nix-action`** | Industry standard, robust caching, reliable. |
| **Weekly Updates** | Daily is too noisy, monthly is too large. Weekly balances drift vs. maintenance. |
| **No Auto-Merge** | **Never** auto-merge system updates. Breaking changes need human eyes. |
| **Use `actions/checkout@v5`** | Use Node 24 runtime (Current state-of-the-art) over v4 (Node 20). |
